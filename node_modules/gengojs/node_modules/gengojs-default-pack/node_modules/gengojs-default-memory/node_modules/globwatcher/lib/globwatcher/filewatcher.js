"use strict";

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var events = require("events");
var fs = require("fs");
var path = require("path");
var Promise = require("bluebird");
var util = require("util");

var FileWatcher = (function () {
  function FileWatcher() {
    var options_in = arguments[0] === undefined ? {} : arguments[0];
    _classCallCheck(this, FileWatcher);

    var options = {
      period: 250,
      persistent: true
    };
    for (var key in options_in) {
      options[key] = options_in[key];
    } // frequency of stat() checking, in milliseconds
    this.period = options.period;
    // should our timer keep the process alive?
    this.persistent = options.persistent;
    // timer that periodically checks for file changes
    this.timer = null;
    // filename -> Watch
    this.watches = {};
    // chain of running checks
    this.ongoing = null;
  }

  _prototypeProperties(FileWatcher, null, {
    close: {
      value: function close() {
        this.watches = {};
        if (this.timer != null) {
          clearInterval(this.timer);
          this.timer = null;
        }
      },
      writable: true,
      configurable: true
    },
    watch: {
      value: function watch(filename) {
        var _this = this;
        var mtime = arguments[1] === undefined ? null : arguments[1];
        var size = arguments[2] === undefined ? null : arguments[2];
        filename = path.resolve(filename);
        var watch = this.watches[filename];
        if (watch == null) {
          watch = this.watches[filename] = new Watch(filename, mtime, size);
        }
        if (this.timer == null) {
          this.timer = setInterval(function () {
            return _this.check();
          }, this.period);
          if (!this.persistent) this.timer.unref();
        }
        return watch;
      },
      writable: true,
      configurable: true
    },
    unwatch: {
      value: function unwatch(filename) {
        filename = path.resolve(filename);
        delete this.watches[filename];
      },
      writable: true,
      configurable: true
    },
    watchFor: {
      value: function watchFor(filename) {
        return this.watches[path.resolve(filename)];
      },
      writable: true,
      configurable: true
    },
    check: {

      // runs a scan of all outstanding watches.
      // if a scan is currently running, the new scan is queued up behind it.
      // returns a promise that will be fulfilled when this new scan is finished.
      value: function check() {
        var _this = this;
        this.ongoing = (this.ongoing || Promise.resolve()).then(function () {
          var watches = Object.keys(_this.watches).map(function (key) {
            return _this.watches[key];
          });
          var completion = Promise.all(watches.map(function (watch) {
            return watch.check();
          }));
          _this.ongoing = completion.then(function () {
            _this.ongoing = null;
          });
          return _this.ongoing;
        });
        return this.ongoing;
      },
      writable: true,
      configurable: true
    }
  });

  return FileWatcher;
})();

var Watch = (function (_events$EventEmitter) {
  function Watch(filename, mtime, size) {
    _classCallCheck(this, Watch);

    this.filename = filename;
    this.mtime = mtime;
    this.size = size;

    this.callbacks = [];
    if (this.mtime == null || this.size == null) {
      try {
        var stat = fs.statSync(this.filename);
        this.mtime = stat.mtime.getTime();
        this.size = stat.size;
      } catch (error) {}
    }
  }

  _inherits(Watch, _events$EventEmitter);

  _prototypeProperties(Watch, null, {
    check: {
      value: function check() {
        var _this = this;
        return Promise.promisify(fs.stat)(this.filename)["catch"](function (error) {
          return null;
        }).then(function (stat) {
          if (_this.mtime != null && stat != null && (_this.mtime != stat.mtime.getTime() || _this.size != stat.size)) {
            _this.emit("changed", stat);
          }
          if (stat != null) {
            _this.mtime = stat.mtime.getTime();
            _this.size = stat.size;
          } else {
            _this.mtime = null;
            _this.size = null;
          }
        });
      },
      writable: true,
      configurable: true
    }
  });

  return Watch;
})(events.EventEmitter);




exports.FileWatcher = FileWatcher;
// nevermind.
//# sourceMappingURL=filewatcher.js.map